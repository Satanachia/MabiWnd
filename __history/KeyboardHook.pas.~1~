unit KeyboardHook;

interface

uses
  Windows, Messages;

const
  WM_USER_KEYCHANGE = WM_USER + 1;

type
  TKeyboardHook = class
  private
    FOldKeys: array[0..255] of Byte;
    FNewKeys: array[0..255] of Byte;
  public
    constructor Create;
    procedure InstallHook;
    procedure UninstallHook;
    function IsKeyPressed(VirtualKey: Byte): Boolean;
  end;

var
  KeyboardHookx: TKeyboardHook;

implementation

var
  Hook: HHOOK = 0;

function KeyboardHookProc(nCode: Integer; wParam: WPARAM; lParam: LPARAM; lpvParam: LPARAM): LRESULT; stdcall;
var
  i: Integer;
  KeyboardHook: TKeyboardHook;
begin
  KeyboardHook := TKeyboardHook(lpvParam);
  if (nCode >= 0) and (wParam = WM_KEYDOWN) then
  begin
    KeyboardHook.FNewKeys[PByte(lParam)^] := $80;
    for i := 0 to 255 do
    begin
      if (KeyboardHook.FNewKeys[i] and $80) <> (KeyboardHook.FOldKeys[i] and $80) then
        PostMessage(GetForegroundWindow, WM_USER_KEYCHANGE, i, lParam);
      KeyboardHook.FOldKeys[i] := KeyboardHook.FNewKeys[i];
    end;
  end;
  Result := CallNextHookEx(0, nCode, wParam, lParam);
end;

constructor TKeyboardHook.Create;
begin
  FillChar(FOldKeys, SizeOf(FOldKeys), 0);
  FillChar(FNewKeys, SizeOf(FNewKeys), 0);
end;

procedure TKeyboardHook.InstallHook;
begin
  Hook := SetWindowsHookEx(WH_KEYBOARD_LL, @KeyboardHookProc, HInstance, 0);
end;

procedure TKeyboardHook.UninstallHook;
begin
  UnhookWindowsHookEx(Hook);
end;

function TKeyboardHook.IsKeyPressed(VirtualKey: Byte): Boolean;
begin
  Result := (GetAsyncKeyState(VirtualKey) and $8000) <> 0;
end;

initialization
  KeyboardHookx := TKeyboardHook.Create;

finalization
  KeyboardHookx.Free;

end.

