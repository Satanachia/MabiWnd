unit HotKey;
unit KeyStateMonitor;

interface

uses
  System.Classes, Winapi.Windows, System.Types;

type
  TKeyStateMonitor = class(TThread)
  private
    FKeyStates: array of SHORT;
    FKeyCombos: array of array of Byte;
    function AnyCombosPressed: Boolean;
  protected
    procedure Execute; override;
  public
    constructor Create(const KeyCombos: array of TByteDynArray); reintroduce;
    property CombosPressed: Boolean read AnyCombosPressed;
  end;

implementation

constructor TKeyStateMonitor.Create(const KeyCombos: array of TByteDynArray);
var
  I, J: Integer;
begin
  inherited Create(True);
  FreeOnTerminate := True;
  SetLength(FKeyStates, Length(KeyCombos));
  SetLength(FKeyCombos, Length(KeyCombos));
  for I := Low(KeyCombos) to High(KeyCombos) do
  begin
    SetLength(FKeyCombos[I], Length(KeyCombos[I]));
    for J := Low(KeyCombos[I]) to High(KeyCombos[I]) do
    begin
      FKeyCombos[I][J] := KeyCombos[I][J];
    end;
  end;
end;


function TKeyStateMonitor.AnyCombosPressed: Boolean;
var
  I, J: Integer;
  ComboPressed: Boolean;
begin
  Result := False;
  for I := Low(FKeyCombos) to High(FKeyCombos) do
  begin
    ComboPressed := True;
    for J := Low(FKeyCombos[I]) to High(FKeyCombos[I]) do
    begin
      if (GetKeyState(FKeyCombos[I][J]) and $80) = 0 then
      begin
        ComboPressed := False;
        Break;
      end;
    end;
    if ComboPressed then
    begin
      Result := True;
      Break;
    end;
  end;
end;

procedure TKeyStateMonitor.Execute;
var
  I, J: Integer;
begin
  while not Terminated do
  begin
    for I := Low(FKeyCombos) to High(FKeyCombos) do
    begin
      for J := Low(FKeyCombos[I]) to High(FKeyCombos[I]) do
      begin
        FKeyStates[I] := GetKeyState(FKeyCombos[I][J]);
        if (FKeyStates[I] and $80) = 0 then
        begin
          Break;
        end;
      end;
    end;
    Sleep(10);
  end;
end;

end.

